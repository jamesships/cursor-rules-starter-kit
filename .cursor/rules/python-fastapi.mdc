---
description: Rules for Python FastAPI backend development
globs: ["**/*.py", "app/**/*", "api/**/*", "tests/**/*"]
alwaysApply: false
---

# Python + FastAPI Development Rules

You are an expert Python developer specializing in FastAPI async web applications.

## Core Principles

1. **Type Hints Everywhere**: All functions must have complete type annotations
2. **Async First**: Use `async def` for I/O operations
3. **Pydantic Models**: Validate all input/output with Pydantic
4. **Dependency Injection**: Use FastAPI's DI system consistently

## Project Structure

```
app/
├── main.py              # FastAPI app instance
├── config.py            # Settings with pydantic-settings
├── models/              # SQLAlchemy/database models
├── schemas/             # Pydantic schemas
├── api/
│   ├── deps.py          # Dependencies
│   └── routes/          # Route handlers
├── services/            # Business logic
├── repositories/        # Data access layer
└── utils/               # Utility functions
tests/
├── conftest.py          # Pytest fixtures
├── unit/                # Unit tests
└── integration/         # Integration tests
```

## Code Patterns

### Pydantic Schemas
```python
from datetime import datetime
from pydantic import BaseModel, Field, ConfigDict

class ItemBase(BaseModel):
    """Base schema for Item."""
    title: str = Field(..., min_length=1, max_length=100)
    description: str | None = Field(default=None, max_length=500)

class ItemCreate(ItemBase):
    """Schema for creating an Item."""
    pass

class ItemResponse(ItemBase):
    """Schema for Item response."""
    model_config = ConfigDict(from_attributes=True)
    
    id: int
    created_at: datetime
    updated_at: datetime
```

### Route Handlers
```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession

from app.api.deps import get_db
from app.schemas.item import ItemCreate, ItemResponse
from app.services.item import ItemService

router = APIRouter(prefix="/items", tags=["items"])

@router.post(
    "/",
    response_model=ItemResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Create a new item",
)
async def create_item(
    item: ItemCreate,
    db: AsyncSession = Depends(get_db),
) -> ItemResponse:
    """Create a new item in the database."""
    service = ItemService(db)
    return await service.create(item)

@router.get("/{item_id}", response_model=ItemResponse)
async def get_item(
    item_id: int,
    db: AsyncSession = Depends(get_db),
) -> ItemResponse:
    """Get an item by ID."""
    service = ItemService(db)
    item = await service.get_by_id(item_id)
    if not item:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Item with id {item_id} not found",
        )
    return item
```

### Service Layer
```python
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.models.item import Item
from app.schemas.item import ItemCreate

class ItemService:
    """Service for item operations."""
    
    def __init__(self, db: AsyncSession) -> None:
        self.db = db
    
    async def create(self, data: ItemCreate) -> Item:
        """Create a new item."""
        item = Item(**data.model_dump())
        self.db.add(item)
        await self.db.commit()
        await self.db.refresh(item)
        return item
    
    async def get_by_id(self, item_id: int) -> Item | None:
        """Get an item by ID."""
        result = await self.db.execute(
            select(Item).where(Item.id == item_id)
        )
        return result.scalar_one_or_none()
```

### Dependencies
```python
from typing import AsyncGenerator
from fastapi import Depends
from sqlalchemy.ext.asyncio import AsyncSession

from app.database import async_session_maker

async def get_db() -> AsyncGenerator[AsyncSession, None]:
    """Database session dependency."""
    async with async_session_maker() as session:
        try:
            yield session
        finally:
            await session.close()
```

## Error Handling

```python
from fastapi import HTTPException, status
from fastapi.responses import JSONResponse
from pydantic import ValidationError

@app.exception_handler(ValidationError)
async def validation_exception_handler(request, exc: ValidationError):
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={"detail": exc.errors()},
    )
```

## Testing Patterns

```python
import pytest
from httpx import AsyncClient
from app.main import app

@pytest.fixture
async def client() -> AsyncGenerator[AsyncClient, None]:
    async with AsyncClient(app=app, base_url="http://test") as ac:
        yield ac

@pytest.mark.asyncio
async def test_create_item(client: AsyncClient) -> None:
    response = await client.post(
        "/items/",
        json={"title": "Test Item", "description": "A test"}
    )
    assert response.status_code == 201
    assert response.json()["title"] == "Test Item"
```

## Do NOT

- Use synchronous database operations in async routes
- Return SQLAlchemy models directly (always use Pydantic)
- Skip type hints on function parameters and returns
- Use global state for database connections
- Catch broad exceptions without re-raising
